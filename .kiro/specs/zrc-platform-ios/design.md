# Design Document: zrc-platform-ios

## Overview

The zrc-platform-ios crate implements iOS-specific functionality for the Zippy Remote Control (ZRC) system. This crate provides a controller application for viewing and controlling remote devices from iPhones and iPads, with limited host capabilities via ReplayKit Broadcast Extension.

## Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          zrc-platform-ios                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      Swift/SwiftUI Layer                              │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                  │   │
│  │  │   Main      │  │   Viewer    │  │  Settings   │                  │   │
│  │  │    App      │  │    View     │  │    View     │                  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘                  │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                  │   │
│  │  │  Device     │  │   Pairing   │  │  Broadcast  │                  │   │
│  │  │   List      │  │    Flow     │  │  Extension  │                  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                         │
│                                    ▼ UniFFI/C-ABI                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      Rust Core (XCFramework)                          │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                  │   │
│  │  │  Session    │  │  Transport  │  │   Crypto    │                  │   │
│  │  │  Manager    │  │   Client    │  │   (zrc-    │                  │   │
│  │  │             │  │             │  │   crypto)   │                  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      iOS Platform APIs                                │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                  │   │
│  │  │  Keychain   │  │   Metal     │  │  ReplayKit  │                  │   │
│  │  │   (Keys)    │  │ (Rendering) │  │   (Host)    │                  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```


## Components and Interfaces

### UniFFI Bridge

```rust
// Rust side - uniffi bindings
uniffi::include_scaffolding!("zrc_ios");

#[derive(uniffi::Object)]
pub struct ZrcCore {
    inner: Arc<Mutex<CoreInner>>,
}

#[uniffi::export]
impl ZrcCore {
    #[uniffi::constructor]
    pub fn new(config_json: String) -> Result<Arc<Self>, ZrcError> {
        let config: Config = serde_json::from_str(&config_json)?;
        let inner = CoreInner::new(config)?;
        Ok(Arc::new(Self {
            inner: Arc::new(Mutex::new(inner)),
        }))
    }
    
    pub fn start_session(&self, device_id: Vec<u8>) -> Result<u64, ZrcError> {
        let mut inner = self.inner.lock().unwrap();
        inner.start_session(&device_id)
    }
    
    pub fn end_session(&self, session_id: u64) -> Result<(), ZrcError> {
        let mut inner = self.inner.lock().unwrap();
        inner.end_session(session_id)
    }
    
    pub fn poll_frame(&self, session_id: u64) -> Option<FrameData> {
        let inner = self.inner.lock().unwrap();
        inner.poll_frame(session_id)
    }
    
    pub fn send_input(&self, session_id: u64, event: InputEvent) -> Result<(), ZrcError> {
        let inner = self.inner.lock().unwrap();
        inner.send_input(session_id, event)
    }
}

#[derive(uniffi::Record)]
pub struct FrameData {
    pub data: Vec<u8>,
    pub width: u32,
    pub height: u32,
    pub timestamp: u64,
}

#[derive(uniffi::Enum)]
pub enum InputEvent {
    MouseMove { x: i32, y: i32 },
    MouseClick { x: i32, y: i32, button: MouseButton },
    KeyPress { code: u32, down: bool },
    Scroll { delta: i32 },
}
```

```swift
// Swift side - generated by UniFFI
// ZrcCore.swift (auto-generated)

public class ZrcCore {
    private let pointer: UnsafeMutableRawPointer
    
    public init(configJson: String) throws {
        self.pointer = try zrc_core_new(configJson)
    }
    
    public func startSession(deviceId: Data) throws -> UInt64 {
        return try zrc_core_start_session(pointer, deviceId)
    }
    
    public func pollFrame(sessionId: UInt64) -> FrameData? {
        return zrc_core_poll_frame(pointer, sessionId)
    }
    
    public func sendInput(sessionId: UInt64, event: InputEvent) throws {
        try zrc_core_send_input(pointer, sessionId, event)
    }
    
    deinit {
        zrc_core_free(pointer)
    }
}
```

### Metal Frame Renderer

```swift
// MetalFrameRenderer.swift
import MetalKit

class MetalFrameRenderer: NSObject, MTKViewDelegate {
    
    private let device: MTLDevice
    private let commandQueue: MTLCommandQueue
    private let pipelineState: MTLRenderPipelineState
    private var currentTexture: MTLTexture?
    
    private var zoom: Float = 1.0
    private var panOffset: CGPoint = .zero
    
    init(metalView: MTKView) throws {
        guard let device = MTLCreateSystemDefaultDevice() else {
            throw RendererError.noDevice
        }
        
        self.device = device
        metalView.device = device
        metalView.colorPixelFormat = .bgra8Unorm
        
        guard let commandQueue = device.makeCommandQueue() else {
            throw RendererError.noCommandQueue
        }
        self.commandQueue = commandQueue
        
        // Create render pipeline
        let library = device.makeDefaultLibrary()!
        let vertexFunction = library.makeFunction(name: "vertexShader")
        let fragmentFunction = library.makeFunction(name: "fragmentShader")
        
        let pipelineDescriptor = MTLRenderPipelineDescriptor()
        pipelineDescriptor.vertexFunction = vertexFunction
        pipelineDescriptor.fragmentFunction = fragmentFunction
        pipelineDescriptor.colorAttachments[0].pixelFormat = metalView.colorPixelFormat
        
        self.pipelineState = try device.makeRenderPipelineState(descriptor: pipelineDescriptor)
        
        super.init()
        metalView.delegate = self
    }
    
    func updateFrame(_ frameData: FrameData) {
        let textureDescriptor = MTLTextureDescriptor.texture2DDescriptor(
            pixelFormat: .bgra8Unorm,
            width: Int(frameData.width),
            height: Int(frameData.height),
            mipmapped: false
        )
        
        guard let texture = device.makeTexture(descriptor: textureDescriptor) else { return }
        
        frameData.data.withUnsafeBytes { ptr in
            texture.replace(
                region: MTLRegionMake2D(0, 0, Int(frameData.width), Int(frameData.height)),
                mipmapLevel: 0,
                withBytes: ptr.baseAddress!,
                bytesPerRow: Int(frameData.width) * 4
            )
        }
        
        currentTexture = texture
    }
    
    func draw(in view: MTKView) {
        guard let texture = currentTexture,
              let commandBuffer = commandQueue.makeCommandBuffer(),
              let renderPassDescriptor = view.currentRenderPassDescriptor,
              let renderEncoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDescriptor)
        else { return }
        
        renderEncoder.setRenderPipelineState(pipelineState)
        renderEncoder.setFragmentTexture(texture, index: 0)
        
        // Apply zoom and pan transforms
        var transform = matrix_identity_float4x4
        transform = matrix_multiply(transform, matrix4x4_scale(zoom, zoom, 1.0))
        transform = matrix_multiply(transform, matrix4x4_translation(Float(panOffset.x), Float(panOffset.y), 0))
        renderEncoder.setVertexBytes(&transform, length: MemoryLayout<matrix_float4x4>.size, index: 1)
        
        renderEncoder.drawPrimitives(type: .triangleStrip, vertexStart: 0, vertexCount: 4)
        renderEncoder.endEncoding()
        
        if let drawable = view.currentDrawable {
            commandBuffer.present(drawable)
        }
        commandBuffer.commit()
    }
    
    func mtkView(_ view: MTKView, drawableSizeWillChange size: CGSize) {}
}
```

### Touch Input Handler

```swift
// TouchInputHandler.swift
import UIKit

class TouchInputHandler {
    
    private let inputSender: InputSender
    private let viewBounds: () -> CGRect
    private let remoteSize: () -> CGSize
    
    private var lastTouchLocation: CGPoint?
    
    init(inputSender: InputSender, viewBounds: @escaping () -> CGRect, remoteSize: @escaping () -> CGSize) {
        self.inputSender = inputSender
        self.viewBounds = viewBounds
        self.remoteSize = remoteSize
    }
    
    func handleTap(at location: CGPoint) {
        let remotePoint = mapToRemote(location)
        inputSender.sendClick(x: Int32(remotePoint.x), y: Int32(remotePoint.y), button: .left)
        
        // Haptic feedback
        let generator = UIImpactFeedbackGenerator(style: .light)
        generator.impactOccurred()
    }
    
    func handleLongPress(at location: CGPoint) {
        let remotePoint = mapToRemote(location)
        inputSender.sendClick(x: Int32(remotePoint.x), y: Int32(remotePoint.y), button: .right)
        
        let generator = UIImpactFeedbackGenerator(style: .medium)
        generator.impactOccurred()
    }
    
    func handlePan(translation: CGPoint, location: CGPoint) {
        let remotePoint = mapToRemote(location)
        inputSender.sendMouseMove(x: Int32(remotePoint.x), y: Int32(remotePoint.y))
    }
    
    func handleTwoFingerScroll(translation: CGPoint) {
        inputSender.sendScroll(delta: Int32(translation.y))
    }
    
    private func mapToRemote(_ local: CGPoint) -> CGPoint {
        let bounds = viewBounds()
        let remote = remoteSize()
        
        let scaleX = remote.width / bounds.width
        let scaleY = remote.height / bounds.height
        
        return CGPoint(
            x: local.x * scaleX,
            y: local.y * scaleY
        )
    }
}
```

### iOS Keychain Storage

```swift
// KeychainStore.swift
import Security

class KeychainStore {
    
    private let service = "io.zippyremote.keys"
    
    func storeKey(name: String, data: Data) throws {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: name,
            kSecValueData as String: data,
            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly,
            kSecAttrSynchronizable as String: false  // Don't sync to iCloud
        ]
        
        // Delete existing item first
        SecItemDelete(query as CFDictionary)
        
        let status = SecItemAdd(query as CFDictionary, nil)
        guard status == errSecSuccess else {
            throw KeychainError.storeFailed(status)
        }
    }
    
    func loadKey(name: String) throws -> Data? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: name,
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]
        
        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)
        
        switch status {
        case errSecSuccess:
            return result as? Data
        case errSecItemNotFound:
            return nil
        default:
            throw KeychainError.loadFailed(status)
        }
    }
    
    func deleteKey(name: String) throws {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: name
        ]
        
        let status = SecItemDelete(query as CFDictionary)
        guard status == errSecSuccess || status == errSecItemNotFound else {
            throw KeychainError.deleteFailed(status)
        }
    }
    
    // Secure Enclave key generation (for signing keys)
    func generateSecureEnclaveKey(name: String) throws -> SecKey {
        var error: Unmanaged<CFError>?
        
        let access = SecAccessControlCreateWithFlags(
            kCFAllocatorDefault,
            kSecAttrAccessibleWhenUnlockedThisDeviceOnly,
            [.privateKeyUsage],
            &error
        )!
        
        let attributes: [String: Any] = [
            kSecAttrKeyType as String: kSecAttrKeyTypeECSECPrimeRandom,
            kSecAttrKeySizeInBits as String: 256,
            kSecAttrTokenID as String: kSecAttrTokenIDSecureEnclave,
            kSecPrivateKeyAttrs as String: [
                kSecAttrIsPermanent as String: true,
                kSecAttrApplicationTag as String: name.data(using: .utf8)!,
                kSecAttrAccessControl as String: access
            ]
        ]
        
        guard let privateKey = SecKeyCreateRandomKey(attributes as CFDictionary, &error) else {
            throw KeychainError.keyGenerationFailed(error!.takeRetainedValue())
        }
        
        return privateKey
    }
}
```

### ReplayKit Broadcast Extension

```swift
// BroadcastSampleHandler.swift (in Broadcast Extension target)
import ReplayKit

class BroadcastSampleHandler: RPBroadcastSampleHandler {
    
    private var zrcCore: ZrcCore?
    private var sessionId: UInt64?
    
    override func broadcastStarted(withSetupInfo setupInfo: [String: NSObject]?) {
        // Initialize ZRC core
        do {
            let config = loadConfig()
            zrcCore = try ZrcCore(configJson: config)
            
            // Connect to waiting controller
            if let deviceId = setupInfo?["deviceId"] as? Data {
                sessionId = try zrcCore?.startSession(deviceId: deviceId)
            }
        } catch {
            finishBroadcastWithError(error)
        }
    }
    
    override func broadcastFinished() {
        if let sessionId = sessionId {
            try? zrcCore?.endSession(sessionId: sessionId)
        }
        zrcCore = nil
    }
    
    override func processSampleBuffer(_ sampleBuffer: CMSampleBuffer, with sampleBufferType: RPSampleBufferType) {
        guard sampleBufferType == .video,
              let sessionId = sessionId,
              let imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer)
        else { return }
        
        CVPixelBufferLockBaseAddress(imageBuffer, .readOnly)
        defer { CVPixelBufferUnlockBaseAddress(imageBuffer, .readOnly) }
        
        let width = CVPixelBufferGetWidth(imageBuffer)
        let height = CVPixelBufferGetHeight(imageBuffer)
        let bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer)
        
        if let baseAddress = CVPixelBufferGetBaseAddress(imageBuffer) {
            let data = Data(bytes: baseAddress, count: bytesPerRow * height)
            
            let frameData = FrameData(
                data: data,
                width: UInt32(width),
                height: UInt32(height),
                timestamp: UInt64(CMSampleBufferGetPresentationTimeStamp(sampleBuffer).seconds * 1000)
            )
            
            try? zrcCore?.sendFrame(sessionId: sessionId, frame: frameData)
        }
    }
}
```

### SwiftUI Views

```swift
// DeviceListView.swift
import SwiftUI

struct DeviceListView: View {
    @StateObject private var viewModel = DeviceListViewModel()
    @State private var showingPairingSheet = false
    
    var body: some View {
        NavigationView {
            List {
                ForEach(viewModel.devices) { device in
                    DeviceRow(device: device)
                        .onTapGesture {
                            viewModel.connect(to: device)
                        }
                }
                .onDelete(perform: viewModel.removeDevices)
            }
            .navigationTitle("Devices")
            .toolbar {
                ToolbarItem(placement: .primaryAction) {
                    Button(action: { showingPairingSheet = true }) {
                        Image(systemName: "plus")
                    }
                }
            }
            .sheet(isPresented: $showingPairingSheet) {
                PairingView(viewModel: PairingViewModel())
            }
        }
    }
}

struct DeviceRow: View {
    let device: Device
    
    var body: some View {
        HStack {
            Circle()
                .fill(device.isOnline ? Color.green : Color.gray)
                .frame(width: 10, height: 10)
            
            VStack(alignment: .leading) {
                Text(device.name)
                    .font(.headline)
                Text(device.id.prefix(8))
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            if let lastSeen = device.lastSeen {
                Text(lastSeen, style: .relative)
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
        }
        .padding(.vertical, 4)
    }
}
```

## Data Models

### Configuration

```swift
struct ZrcConfig: Codable {
    let rendezvousUrls: [String]
    let relayUrls: [String]
    let transportPreference: TransportPreference
    
    enum TransportPreference: String, Codable {
        case auto, mesh, direct, relay
    }
}
```

## Correctness Properties

### Property 1: Metal Rendering Performance
*For any* frame sequence, rendering SHALL maintain 60fps on devices with ProMotion displays.
**Validates: Requirements 1.7, 1.8**

### Property 2: Touch Coordinate Accuracy
*For any* touch event, the mapped remote coordinates SHALL be within ±1 pixel of the mathematically correct mapping.
**Validates: Requirements 2.1, 2.4**

### Property 3: Keychain Security
*For any* key stored in Keychain, synchronizable SHALL be false to prevent iCloud sync.
**Validates: Requirements 8.5, 8.6**

### Property 4: Broadcast Extension Memory
*For any* broadcast session, memory usage SHALL stay within iOS extension limits (50MB).
**Validates: Requirement 7.7**

### Property 5: Background Task Completion
*For any* app backgrounding during session, a background task SHALL be started to allow graceful disconnect.
**Validates: Requirement 4.7**

## Error Handling

| Error Condition | Response | Recovery |
|-----------------|----------|----------|
| Metal device unavailable | Fall back to CPU rendering | Warn user |
| Keychain access denied | Show permission dialog | Guide user |
| Broadcast extension crash | End broadcast | Notify user |
| Network change | Attempt reconnection | Show status |
| Memory pressure | Drop frames | Continue operation |

## Testing Strategy

### Unit Tests
- UniFFI binding correctness
- Coordinate mapping
- Keychain operations
- Configuration parsing

### Integration Tests
- Full session flow
- Metal rendering pipeline
- Touch input handling
- Broadcast extension

### Device Tests
- Various iOS versions (15+)
- iPhone vs iPad
- ProMotion displays
- Hardware keyboard (iPad)
