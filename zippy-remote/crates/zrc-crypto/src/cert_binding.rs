//! Certificate binding module for identity-bound DTLS.
//!
//! This module provides functions to bind DTLS certificates to device identities,
//! preventing signaling MITM attacks by cryptographically linking the DTLS
//! certificate fingerprint to the device's Ed25519 signing key.

use ed25519_dalek::{Signature, Signer, SigningKey, VerifyingKey};

use crate::identity::Identity;
use crate::transcript::Transcript;
use crate::hash::sha256;

/// Error type for cert binding operations.
#[derive(Debug, thiserror::Error)]
pub enum CertBindingError {
    #[error("invalid fingerprint length: expected 32, got {0}")]
    InvalidFingerprintLength(usize),
    #[error("invalid signature length: expected 64, got {0}")]
    InvalidSignatureLength(usize),
    #[error("invalid public key length: expected 32, got {0}")]
    InvalidPublicKeyLength(usize),
    #[error("signature verification failed")]
    SignatureVerificationFailed,
    #[error("signer_pub does not match expected public key")]
    SignerMismatch,
}

/// A cryptographic binding between a DTLS certificate and a device identity.
///
/// This structure contains:
/// - The SHA-256 fingerprint of the DTLS certificate
/// - An Ed25519 signature of that fingerprint
/// - The signer's Ed25519 public key
///
/// This binding is used during WebRTC signaling to prove that the DTLS
/// certificate was generated by the claimed device identity.
#[derive(Debug, Clone)]
pub struct CertBinding {
    /// SHA-256 fingerprint of the DTLS certificate (32 bytes)
    pub fingerprint: [u8; 32],
    /// Ed25519 signature over the fingerprint (64 bytes)
    pub signature: [u8; 64],
    /// Signer's Ed25519 public key (32 bytes)
    pub signer_pub: [u8; 32],
}

impl CertBinding {
    /// Create a CertBinding from its component parts.
    pub fn new(fingerprint: [u8; 32], signature: [u8; 64], signer_pub: [u8; 32]) -> Self {
        Self {
            fingerprint,
            signature,
            signer_pub,
        }
    }

    /// Create a CertBinding from byte slices, validating lengths.
    pub fn from_bytes(
        fingerprint: &[u8],
        signature: &[u8],
        signer_pub: &[u8],
    ) -> Result<Self, CertBindingError> {
        if fingerprint.len() != 32 {
            return Err(CertBindingError::InvalidFingerprintLength(fingerprint.len()));
        }
        if signature.len() != 64 {
            return Err(CertBindingError::InvalidSignatureLength(signature.len()));
        }
        if signer_pub.len() != 32 {
            return Err(CertBindingError::InvalidPublicKeyLength(signer_pub.len()));
        }

        let mut fp = [0u8; 32];
        let mut sig = [0u8; 64];
        let mut pk = [0u8; 32];

        fp.copy_from_slice(fingerprint);
        sig.copy_from_slice(signature);
        pk.copy_from_slice(signer_pub);

        Ok(Self {
            fingerprint: fp,
            signature: sig,
            signer_pub: pk,
        })
    }
}

/// Build the canonical data to sign for a cert binding.
fn cert_binding_sign_data(fingerprint: &[u8; 32]) -> [u8; 32] {
    let mut t = Transcript::new("zrc_cert_binding_v1");
    t.append_bytes(1, fingerprint);
    sha256(t.as_bytes())
}

/// Sign a DTLS certificate fingerprint with a device identity.
///
/// This creates a cryptographic binding between the DTLS certificate
/// and the device's Ed25519 signing key.
///
/// # Arguments
/// * `identity` - The device identity to sign with
/// * `fingerprint` - The SHA-256 fingerprint of the DTLS certificate (32 bytes)
///
/// # Returns
/// A CertBinding containing the fingerprint, signature, and signer's public key.
pub fn sign_cert_fingerprint(identity: &Identity, fingerprint: &[u8; 32]) -> CertBinding {
    let sign_data = cert_binding_sign_data(fingerprint);
    let signature = identity.sign(&sign_data);
    let signer_pub = identity.sign_pub();

    CertBinding {
        fingerprint: *fingerprint,
        signature,
        signer_pub,
    }
}

/// Sign a DTLS certificate fingerprint with a raw signing key.
///
/// # Arguments
/// * `sign_key` - The Ed25519 signing key
/// * `fingerprint` - The SHA-256 fingerprint of the DTLS certificate (32 bytes)
///
/// # Returns
/// A CertBinding containing the fingerprint, signature, and signer's public key.
pub fn sign_cert_fingerprint_with_key(
    sign_key: &SigningKey,
    fingerprint: &[u8; 32],
) -> CertBinding {
    let sign_data = cert_binding_sign_data(fingerprint);
    let signature: Signature = sign_key.sign(&sign_data);
    let signer_pub = sign_key.verifying_key().to_bytes();

    CertBinding {
        fingerprint: *fingerprint,
        signature: signature.to_bytes(),
        signer_pub,
    }
}

/// Verify a certificate binding.
///
/// This verifies that:
/// 1. The signature is valid for the fingerprint
/// 2. The signer_pub matches the expected public key (from PairReceipt)
///
/// # Arguments
/// * `binding` - The CertBinding to verify
/// * `expected_pub` - The expected signer's public key (from PairReceipt)
///
/// # Returns
/// Ok(()) if the binding is valid, or an error describing the failure.
pub fn verify_cert_binding(
    binding: &CertBinding,
    expected_pub: &[u8; 32],
) -> Result<(), CertBindingError> {
    // Verify the signer_pub matches expected
    if binding.signer_pub != *expected_pub {
        return Err(CertBindingError::SignerMismatch);
    }

    // Verify the signature
    let sign_data = cert_binding_sign_data(&binding.fingerprint);

    let verifying_key = VerifyingKey::from_bytes(&binding.signer_pub)
        .map_err(|_| CertBindingError::SignatureVerificationFailed)?;

    let signature = Signature::from_bytes(&binding.signature);

    verifying_key
        .verify_strict(&sign_data, &signature)
        .map_err(|_| CertBindingError::SignatureVerificationFailed)
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand_core::OsRng;

    #[test]
    fn test_cert_binding_round_trip() {
        let identity = Identity::generate();
        let fingerprint = [0x42u8; 32]; // Example DTLS cert fingerprint

        let binding = sign_cert_fingerprint(&identity, &fingerprint);
        let expected_pub = identity.sign_pub();

        assert!(verify_cert_binding(&binding, &expected_pub).is_ok());
    }

    #[test]
    fn test_cert_binding_wrong_expected_key() {
        let identity1 = Identity::generate();
        let identity2 = Identity::generate();
        let fingerprint = [0x42u8; 32];

        let binding = sign_cert_fingerprint(&identity1, &fingerprint);
        let wrong_pub = identity2.sign_pub();

        assert!(matches!(
            verify_cert_binding(&binding, &wrong_pub),
            Err(CertBindingError::SignerMismatch)
        ));
    }

    #[test]
    fn test_cert_binding_tampered_fingerprint() {
        let identity = Identity::generate();
        let fingerprint = [0x42u8; 32];

        let mut binding = sign_cert_fingerprint(&identity, &fingerprint);
        let expected_pub = identity.sign_pub();

        // Tamper with the fingerprint
        binding.fingerprint[0] ^= 0xFF;

        // Verification should fail because the signature doesn't match
        assert!(matches!(
            verify_cert_binding(&binding, &expected_pub),
            Err(CertBindingError::SignatureVerificationFailed)
        ));
    }

    #[test]
    fn test_cert_binding_tampered_signature() {
        let identity = Identity::generate();
        let fingerprint = [0x42u8; 32];

        let mut binding = sign_cert_fingerprint(&identity, &fingerprint);
        let expected_pub = identity.sign_pub();

        // Tamper with the signature
        binding.signature[0] ^= 0xFF;

        assert!(matches!(
            verify_cert_binding(&binding, &expected_pub),
            Err(CertBindingError::SignatureVerificationFailed)
        ));
    }

    #[test]
    fn test_cert_binding_with_raw_key() {
        let sign_key = SigningKey::generate(&mut OsRng);
        let fingerprint = [0xAB; 32];

        let binding = sign_cert_fingerprint_with_key(&sign_key, &fingerprint);
        let expected_pub = sign_key.verifying_key().to_bytes();

        assert!(verify_cert_binding(&binding, &expected_pub).is_ok());
    }

    #[test]
    fn test_cert_binding_from_bytes() {
        let identity = Identity::generate();
        let fingerprint = [0x55u8; 32];

        let original = sign_cert_fingerprint(&identity, &fingerprint);

        // Convert to bytes and back
        let reconstructed = CertBinding::from_bytes(
            &original.fingerprint,
            &original.signature,
            &original.signer_pub,
        )
        .unwrap();

        assert_eq!(original.fingerprint, reconstructed.fingerprint);
        assert_eq!(original.signature, reconstructed.signature);
        assert_eq!(original.signer_pub, reconstructed.signer_pub);

        // Verify the reconstructed binding
        let expected_pub = identity.sign_pub();
        assert!(verify_cert_binding(&reconstructed, &expected_pub).is_ok());
    }

    #[test]
    fn test_cert_binding_determinism() {
        let identity = Identity::generate();
        let fingerprint = [0x77u8; 32];

        // Same fingerprint and identity should produce the same binding
        let binding1 = sign_cert_fingerprint(&identity, &fingerprint);
        let binding2 = sign_cert_fingerprint(&identity, &fingerprint);

        assert_eq!(binding1.fingerprint, binding2.fingerprint);
        assert_eq!(binding1.signer_pub, binding2.signer_pub);
        // Note: Ed25519 signatures are deterministic, so signatures should also match
        assert_eq!(binding1.signature, binding2.signature);
    }
}
